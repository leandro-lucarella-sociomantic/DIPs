# Providing more selective control over run-time checks

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | DIP1006                                                         |
| Review Count:   | 1 [Most Recent]                                                 |
| Author:         | Mathias Lang - mathias.lang@sociomantic.com                     |
|                 | Leandro Lucarella - leandro.lucarella@sociomantic.com           |
| Implementation: | None                                                            |
| Status:         | Formal Review                                         |

[Most Recent]:
https://github.com/dlang/DIPs/blob/6a26586dc4479e63c01f78f49ccda329f1eef500/DIPs/DIP1006.md


## Abstract

Add a new `-checks` command-line option to selectively control D's run-time
checks (`invariant`, `in`, `out`, `assert`, bounds checking and unexpected cases
in `switch`) and to unify the existing ways to customize run-time checks
(`-release` and `-boundscheck`).

### Reference

* Limited D1 implementation, used by Sociomantic:
  https://github.com/dlang/dmd/pull/6347

* Similar proposal in the form of a PR by Martin Novak:
  https://github.com/dlang/dmd/pull/7980


## Contents
* [Rationale](#rationale)
* [Description](#description)
* [Breaking Changes and Deprecations](#breaking-changes-and-deprecations)
* [Copyright & License](#copyright--license)
* [Reviews](#reviews)


## Rationale

### Run-time checks in D

The D compiler provides some run-time checks to improve code safety which
can be disabled when maximum performance is required for production code.

The following run-time checks, which can currently be disabled via two
command-line options (`-release` and `-boundscheck`), are identified:

* `assert` invocations
* `in` contract compilation and implicit invocation
* `out` contract compilation and implicit invocation
* `invariant` compilation and implicit invocation on every `public`/`protected`
  method invocation
* bounds checking for all code, and bounds checking only for `@safe` code
* throwing `SwitchError` on unhandled `switch` cases (the compiler-generated
  `default` case in a `switch` statement throws a `SwitchError` or is replaced
  with the HLT instruction depending on the presence of `-release`)

Some of these checks are known to be potentially too expensive for production
code (see [the `invariant` pathological case](#the-invariant-pathological-case))
but the compiler only provides an all-or-nothing approach via the
`-release` option, disabling almost all checks (except for bounds checking in
`@safe` code, which can be explicitly disabled via `-boundscheck=off`).

There is a lack of fine control for the other potentially expensive run-time
checks. It is known that users sometimes need that level of granularity to
balance the ratio of guarantees vs performance they require from their code. All
other D compilers (LDC and GDC) already provide more fine-grained control over
these checks, but the command-line option names are not standardized, making it
difficult for users to switch between compilers.

### The `invariant` pathological case

While `assert` and `in` / `out` contracts follow a pay-for-what-you-use
approach (an `assert` which is never executed is free, and an `in` or `out`
contract on a function that is never called is also free of runtime overhead),
`invariant` incurs a performance penalty even if user code contains zero
`invariant`s. `invariant`s are implicitly invoked **twice** for every
`public` and `protected` class method call.

The call itself is not direct: the compiler inserts a call to `_d_invariant`,
[which can be found in
druntime](https://github.com/dlang/druntime/blob/v2.072.0/src/rt/invariant.d).
The code, being very simple, results in the class hierarchy being traversed
**twice** (no caching is done) for every call, even for classes which
do not define any invariant.

Profiling some real-time applications within Sociomantic showed that
`_d_invariant` was the most expensive call in the application. Affected
applications were using few or no invariants, but since Sociomantic code is
mostly written in an OOP style, simply disabling invariants (with no other
optimization) led to 20% more throughput.

### Summary of the current issues

* Not all user code needs the same level of safety in expense of performance, so
  different applications need to be able to select which run-time checks should
  be added by the compiler for different purposes

* Not all run-time checks follow the pay-as-you-go philosophy, so they can be
  very expensive even when they are not explicitly used

* Not all compilers offer the same (minimum) level of fine-grained control

* Current command-line options controlling run-time checks are too broad (or
  non-standard) and inconsistent


## Description

Add a command-line option, named `-checks`, which allows the user to control
which run-time checks will be inserted in compiled code by the compiler.

This proposal requires no changes to the language itself; it only affects the
command-line interface of the compiler.

### Command-line option values

The options takes a comma-separated list of checks that can be enabled or
disabled via a prefix indicator (`+` and `-` respectively).

The available values are:

* `assert`: enable/disable all `assert()` invocations
* `in`: enable/disable all `in` contract blocks
* `out`: enable/disable all `out` contract blocks
* `invariant`: enable/disable invariant implicit invocation on every
  `public`/`protected` method call
* `bounds`: enable/disable bound checks in all the code
* `boundssafe`: enable/disable bound checks only in safe code
* `switcherror`: enable/disable throwing a `SwitchError` for unhandled `switch`
  cases
* `all`: enable/disable all checks

### Command-line option processing

Compiling without any `-checks` options is equivalent to compiling with
`-checks=+all` (i.e. by default all checks are enabled).

The `-checks` command-line option can appear multiple times in a single
command-line, the effect being the same as if there were only one `-checks`
option with all values `join()`ed together in the same order by comma.

For example: `-checks=-all -checks=+boundssafe -checks=+switcherror,+in` is
equivalent to `-checks=-all,+boundssafe,+switcherror,+in`.

Option processing is also ordered and each encountered value in the `-checks`
option will modify the previous state of the enabled checks, so the previous
example means that:

1. An implicit `-checks=+all` is first prepended to the explicitly passed
   options, resulting in `-checks=+all,-all,+boundssafe,+switcherror,+in`.
2. `+all` is processed, so all checks are enabled.
3. `-all` is processed, so all checks are disabled.
4. `+boundssafe` is processed, so only `boundssafe` checks are enabled.
5. `+switcherror` is processed, so only `boundssafe` and `switcherror` are
   enabled.
6. `+in` is processed, so only `boundssafe`, `switcherror` and `in` are
   enabled.

### Special cases and particular interactions

#### `assert` inside `in` / `out` / `invariant` contract blocks

If `assert`s are disabled, `assert`s in contract blocks `in` / `out`
/ `invariant` will be removed too, but the blocks will be still compiled in and
run as expected (unless they are disabled too via `-checks=-xxx`). The user
should decide how to make those blocks useful when these particular combination
of checks are used (by using `enforce()` or other types of checks inside those
blocks if they want to disable `asserts` in general).

#### `invariant` and explicit invocation via `assert`

`invariant`s can be invoked in two ways:

* explicitly via `assert(object)`
* implicitly via a call to a `public` or `protected` method

Because of this, the presence of `invariant` code in the object file/binary
is subject to  both `invariant` and `assert` checks.

If `-check=-invariant,+assert` is used, the `invariant` function will still be
present in the object file. Though it will **not** be invoked implicitly, it
might be invoked explicitly via `assert(object)`. To completely remove
`invariant`s from object files, both `invariant` and `assert` must be disabled
(`-invariant,-assert`).

#### `bounds` and `boundssafe`

`bounds` is the only option that encompasses another option: `boundssafe`.
`bounds` enables bounds checking in all `@safe`, `@trusted` and `@system`, while
`boundssafe` only enables it in `@safe` code. There is currently no way to
control `@trusted` and `@system` independently; this capability is also
ignored by this proposal, as it is difficult to find a practical use for it.

Combining both `bounds` and `boundssafe`, one can enable or disable different
combinations of these two packages:

* `+bounds` -> enable all `@safe`, `@trusted` and `@system` code bounds checking
  (equivalent to the current `-boundscheck=on`)
* `+bounds,-boundssafe` -> enable only `@trusted` and `@system` code bounds
  checking (not very practical but possible now)
* `-bounds` -> disable all `@safe`, `@trusted` and `@system` code bounds
  checking (equivalent to the current `-boundscheck=off`)
* `-bounds,+boundssafe` -> enable only `@safe` code bounds checking (equivalent
  to the current `-boundscheck=safeonly`)

It would be also possible to have disjoint options (for example `boundsunsafe`
and `boundssafe`) but it seems more confusing and less practical to use, as
disabling all bounds checking would mean using `-boundsunsafe,-boundssafe`.

#### `switcherror`

When `-switcherror` is specified the check is not actually completely removed.
If an unhandled `switch` case is hit at run-time, instead of throwing
a `SwitchError` the compiler will insert a `HLT` instruction (avoiding the
exception handling overhead). This is what `-release` currently does.

### Interaction with other command-line options

#### `-release`

The `-release` command-line option becomes an alias to
`-checks=-all,+boundssafe` and is processed as such. It other words, its
position in the command line becomes meaningful.

For example `-checks=+invariant -release` will be translated to
`-checks=+invariant,-all,+boundssafe`, which means the only `boundssafe` checks
will be enabled (`+invariant` checks are disabled by the next `-all` option).

To enable `invariant` checks in an existing `-release` build, the ordering
should instead be `-release -checks=+invariant`.

The reason for not requiring special treatment for `-release` in regards to
ordering, even when it might appear counter-intuitive to some users at first, is
that otherwise there would be no way to override the behavior of `-release` with
subsequent command-line options.

Suppose a config file includes `-release` in a set of default flags. No
invocation of `dmd` would be able to enable any further checks if `-release`
were order-agnostic and overrode any other `-checks` options.


#### `-debug`

The `-checks` option doesn't interfere at all with the `-debug` option, which
only enables `debug` blocks. `debug` blocks that are compiled in when using
`-debug` will be subject to the same checks specified by `-checks` as any other
parts of the user code.

In particular, if they contain `assert()` calls and `-assert` is specified, those
`assert()` calls wont run, but all other code in the `debug` block will. It is up
to the user to decide which language facilities to use inside `debug` blocks.

#### `-unittest`

The `-checks` option doesn't interfere at all with the `-unittest` option, which
only enables `unittest` blocks (compiles them and, depending on the `druntime`
unit test runner, runs them as part of the program's initialization).

`unittest` blocks that are compiled in when using `-unittest` will be subject to
the same checks specified by `-checks` as any other parts of the user code.

In particular, if they contain `assert()` calls and `-assert` is specified,
those `assert()` calls wont run, but all other code in the `unittest` block
will. It is up to the user to decide which language facilities to use inside
`unittest` blocks.

### Implementation difficulty

The reference front end already segments the affected features into separate
flags, hence the implementation should be trivial. There are already proposed
implementations for slightly different incarnations of this proposal.


## Breaking Changes and Deprecations

The `-release` option will become an alias for `-checks=-all,+boundssafe` and
thus it becomes sensitive to command-line ordering issues, but this only affects
the uses of the new command-line option, so old compiler invocations using
`-release` will not be affected by this proposal.

Eventually `-release` could be deprecated too, but there is no current timeline
for this, as having a very simple option as an alias for the most common case for
production code could be quite convenient for users.

The `-boundscheck` options will preserve the current semantics (not subject to
command-line options ordering), but it will be deprecated in favor of the new
`-checks` option.

No breaking changes are expected.


## Copyright & License

Copyright (c) 2017-2018 by the D Language Foundation

Licensed under [Creative Commons Zero
1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)


## Reviews

[Preliminary Review Round
1](http://forum.dlang.org/post/rsafosvkhxddkxptaziy@forum.dlang.org).
