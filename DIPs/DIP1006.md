# Providing more selective control over run-time checks

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | DIP1006                                                         |
| Review Count:   | 1 [Most Recent]                                                 |
| Author:         | Mathias Lang - mathias.lang@sociomantic.com                     |
|                 | Leandro Lucarella - leandro.lucarella@sociomantic.com           |
| Implementation: | None                                                            |
| Status:         | Formal Review                                         |

[Most Recent]:
https://github.com/dlang/DIPs/blob/6a26586dc4479e63c01f78f49ccda329f1eef500/DIPs/DIP1006.md


## Abstract

Add a new `-checks` command-line option to selectively control D's run-time
checks (`invariant`, `in`, `out`, `assert`, bounds checking and unexpected cases
in `switch`) and unifying the current existing ways to customize run-time checks
(`-release` and `-boundscheck`).

### Reference

* Limited D1 implementation, used by Sociomantic:
  https://github.com/dlang/dmd/pull/6347

* Similar proposal in the form of a PR by Martin Novak:
  https://github.com/dlang/dmd/pull/7980


## Contents
* [Rationale](#rationale)
* [Description](#description)
* [Breaking Changes and Deprecations](#breaking-changes-and-deprecations)
* [Copyright & License](#copyright--license)
* [Reviews](#reviews)


## Rationale

### Run-time checks in D

The D compiler adds some run-time checks to improve the safety of the code which
can be disabled in case maximum performance is needed for production code.

The following run-time checks, that can be currently disabled via a command-line
option (`-release` and `-boundscheck`), are identified:

* `assert` invocations
* `in` contracts compilation and implicit invocation
* `out` contracts compilation and implicit invocation
* `invariant` compilation and implicit invocation on every `public`/`protected`
  method invocation
* Bound checking for all code and in particular only for `@safe` code
* Throwing `SwitchError` on unhandled `switch` cases (compiler-generated
  `default` case in a `switch` statement throws a `SwitchError` or is turned
  into HLT instruction depending on the presence of `-release`)

Some of these checks are known to be potentially too expensive for production
code (see [the `invariant` pathological case](#the-invariant-pathological-case))
but the compiler only provides a everything-or-nothing approach via the
`-release` option, disabling almost all checks (except for bounds checking in
`@safe` code, which can be explicitly disabled via `-boundscheck=off`).

There is a lack of fine-control for the other potentially expensive run-time
checks, and it is known that users sometimes need that kind of granularity,
depending on the level of guarantees vs performance they need to get from their
code. All other D compilers (LCD and GDC) already provide a more fine grained
control over these checks but what level of granularity and the command-line
option names are not standardized, making it difficult for users to switch
between compilers.

### The `invariant` pathological case

While `assert` and `in` / `out` contracts follow a pay-for-what-you-use
approach (an `assert` which is never executed is free, and a `in` or `out`
contract on a function that is never called is also free of runtime overhead),
`invariant` incurs in a performance penalty even if the user code have zero
`invariant`s in it. `invariant`s are invoked implicitly **twice** for every
`public` and `protected` class method call.

The call itself is not direct: the compiler inserts a call to `_d_invariant`,
[which can be found in
druntime](https://github.com/dlang/druntime/blob/v2.072.0/src/rt/invariant.d).
The code, being very simple, results in the class hierarchy being traversed
completely **twice** (no caching is done) for every call, even for classes which
do not define any invariant.

Profiling some real-time applications within Sociomantic showed that
`_d_invariant` was the most expensive call in the application. Affected
applications were using few or no invariants, but since Sociomantic code is
mostly written in an OOP style, simply disabling invariants (with no other
optimization) led to 20% more throughput.

### Summary of the current issues

* Not all user code needs the same level of safety in expense of performance, so
  different applications need to be able to select which run-time checks should
  be added by the compiler for different purposes

* Not all run-time checks follow the pay-as-you-go philosophy, so they can be
  very expensive even when they are not explicitly used

* Not all compilers offer the same (minimum) level of fine-grained control

* Current command-line options controlling run-time checks are too broad (or
  non-standard) and inconsistent


## Description

Add a command-line option, named `-checks`, which lets the user control which
run-time checks will be inserted in compiled code by the compiler.

This proposal doesn't need any changes to the language itself, it only affects
the command-line interface of the compiler.

### Command-line option values

The options takes a comma-separated list of checks that can be turned on or off
via a prefix indicator (`+` and `-` respectively).

The available values are:

* `assert`: enable/disable all `assert()` invocations
* `in`: enable/disable all `in` contract blocks
* `out`: enable/disable all `out` contract blocks
* `invariant`: enable/disable invariant implicit invocation on every
  `public`/`protected` method call
* `bounds`: enable/disable bound checks in all the code
* `boundssafe`: enable/disable bound checks only in safe code
* `switcherror`: enable/disable throwing a `SwitchError` for unhandled `switch`
  cases
* `all`: enable/disable all checks

### Command-line option processing

Compiling without any options controlling checks is equivalent to compile using
`-checks=+all` (i.e. by default all checks are enabled).

The `-checks` command-line option can also appear multiple times in the
command-line, and the effect of that is the same as if there was only one
`-checks` option with all values `join()`ed together via a comma, in order.

For example: `-checks=-all -checks=+boundssafe -checks=+switcherror,+in` is
equivalent to `-checks=-all,+boundssafe,+switcherror,+in`.

Option processing is also ordered and each encountered value in the `-checks`
option will modify the previous state of the enabled checks, so the previous
example means that:

1. An implicit `-checks=+all` is first prepended to the explicitly passed
   options, resulting in `-checks=+all,-all,+boundssafe,+switcherror,+in`.
2. `+all` is processed, so all checks are enabled.
3. `-all` is processed, so all checks are disabled.
4. `+boundssafe` is processed, so only `boundssafe` checks are enabled.
5. `+switcherror` is processed, so only `boundssafe` and `switcherror` are
   enabled.
6. `+in` is processed, so only `boundssafe`, `switcherror` and `in` are
   enabled.

### Special cases and particular interactions

#### `assert` inside `in` / `out` / `invariant` contract blocks

If `assert`s are disabled, `assert`s in contract blocks `in` / `out`
/ `invariant` will be removed too, but the blocks will be still compiled in and
run as expected (unless they are disabled too via `-checks=-xxx`). The user
should decide how to make those blocks useful when these particular combination
of checks are used (by using `enforce()` or other types of checks inside those
blocks if they want to disable `asserts` in general).

#### `invariant` and explicit invocation via `assert`

`invariant`s can be invoked in 2 ways:

* Explicitly via `assert(object)`
* Implicitly via a call to a `public` or `protected` method

Because of this, the presence of the `invariant` code in the object file/binary
is subject to  both `invariant` and `assert` checks.

If `-check=-invariant,+assert` is used, the `invariant` function will be still
present in the object file (but it will **not** be invoked implicitly), as it
might be invoked explicitly via `assert(object)`. To completely remove
`invariant`s from object files, both `invariant` and `assert` must be disabled
(`-invariant,-assert`).

#### `bounds` and `boundssafe`

`bounds` is the only option that includes another option: `boundssafe`.
`bounds` enable bounds checking in all `@safe`, `@trusted` and `@system`, while
`boundssafe` only enables it in `@safe` code. There is currently no way to
control `@trusted` and `@system` independently and this capability is also
ignored by this proposal as is hard to find a practical use for it.

Combining both `bounds` and `boundssafe` one can enable or disable different
combinations of these 2 packages though:

* `+bounds` -> enable all `@safe`, `@trusted` and `@system` code bounds checking
  (what `-boundscheck=on` currently does)
* `+bounds,-boundssafe` -> enable only `@trusted` and `@system` code bounds
  checking (not very practical but possible now)
* `-bounds` -> disable all `@safe`, `@trusted` and `@system` code bounds
  checking (what `-boundscheck=off` currently does)
* `-bounds,+boundssafe` -> enable only `@safe` code bounds checking (what
  `-boundscheck=safeonly` currently does)

It would be also possible to have disjoint options (for example `boundsunsafe`
and `boundssafe`) but it seems more confusing and less practical to use as
disabling all bounds checking would mean using `-boundsunsafe,-boundssafe`.

#### `switcherror`

When `-switcherror` is specified the check is not actually completely removed.
If an unhandled `switch` case is hit at run-time, instead of throwing
a `SwitchError` the compiler will insert a `HLT` instruction (avoiding the
exception handling overhead). This is also what `-release` currently does.

### Interaction with other command-line options

#### `-release`

The `-release` command-line option becomes an alias to
`-checks=-all,+boundssafe`, and is processed as if it were replaced with that.

For example `-checks=+invariant -release` will be translated to
`-checks=+invariant,-all,+boundssafe`, which means the only `boundssafe` checks
will be enabled (`+invariant` checks are disabled by the next `-all` option).

To enable `invariant` checks to a current `-release` build `-release
-checks=+invariant` should be used instead.

The reason not to treat `-release` specially to not care about ordering, even
when it might sound counter-intuitive to some users at first, is that if this
would be the case there would be no way to override that `-release` do with
further command-line options.

Supose some config file include as the default flags `-release`. Any invocation
of `dmd` would not be able to enable any further checks if `-release` were order
agnostic and override any other `-checks` option.


#### `-debug`

The `-checks` option doesn't interfere at all with the `-debug` option, which
only enable `debug` blocks. `debug` blocks that are compiled in when using
`-debug` will be subject to the same checks specified by `-checks` as any other
parts of the user code.

In particular if they contain `assert()` calls and `-assert` is specified, those
`assert()` calls wont run, but all other code in the `debug` block will. Is up
to the user to decide which language facilities to use inside `debug` blocks.

#### `-unittest`

The `-checks` option doesn't interfere at all with the `-unittest` option, which
only enable `unittest` blocks (compile them and, depending on the `druntime`
unit test runner, runs them as part of the program's initialization).

`unittest` blocks that are compiled in when using `-unittest` will be subject to
the same checks specified by `-checks` as any other parts of the user code.

In particular if they contain `assert()` calls and `-assert` is specified, those
`assert()` calls wont run, but all other code in the `unittest` block will. Is up
to the user to decide which language facilities to use inside `unittest` blocks.

### Implementation difficulty

The reference front-end already segments the affected features into separate
flags, hence the implementation should be trivial. There are already proposed
implementations for slightly different incarnations of this proposal.


## Breaking Changes and Deprecations

The `-release` option will become an alias for `-checks=-all,+boundssafe` and
thus it becomes sensitive to command-line ordering issues, but this only affects
the uses of the new command-line option, so old compiler invocations using
`-release` will not be affected by this proposal.

Eventually `-release` could be deprecated too, but there is no current time-line
for this as having a very simple option as an alias for the most common case for
production code could be quite convenient for users.

The `-boundscheck` options will preserve the current semantics (not subject to
command-line options ordering) but it will be deprecated in favour of the new
`-checks` option.

No breaking changes are expected.


## Copyright & License

Copyright (c) 2017-2018 by the D Language Foundation

Licensed under [Creative Commons Zero
1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)


## Reviews

[Preliminary Review Round
1](http://forum.dlang.org/post/rsafosvkhxddkxptaziy@forum.dlang.org).
